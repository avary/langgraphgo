<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">LangGraphGo èŠå¤©</title>
    <!-- Load only essential CSS immediately -->
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

    <!-- Lazy load heavy libraries only when needed -->
    <script>
        // Lazy loading utilities
        window.librariesLoading = {};
        window.librariesLoaded = {};

        function loadLibrary(name, url, onLoad) {
            if (window.librariesLoaded[name]) {
                if (onLoad) onLoad();
                return Promise.resolve();
            }

            if (window.librariesLoading[name]) {
                return window.librariesLoading[name];
            }

            window.librariesLoading[name] = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.async = true;
                script.onload = () => {
                    window.librariesLoaded[name] = true;
                    if (onLoad) onLoad();
                    resolve();
                };
                script.onerror = reject;
                document.head.appendChild(script);
            });

            return window.librariesLoading[name];
        }

        // Load marked.js immediately (lightweight and essential)
        loadLibrary('marked', 'https://cdn.bootcdn.net/ajax/libs/marked/11.1.1/marked.min.js');

        // Load highlight.js immediately (relatively small)
        loadLibrary('highlightjs', 'https://cdn.bootcdn.net/ajax/libs/highlight.js/11.9.0/highlight.min.js');

        // Lazy load Mermaid (3.3MB, only when needed)
        window.loadMermaid = function() {
            return loadLibrary('mermaid', 'https://cdn.bootcdn.net/ajax/libs/mermaid/10.9.0/mermaid.min.js', () => {
                if (typeof mermaid !== 'undefined') {
                    mermaid.initialize({
                        startOnLoad: false,
                        theme: 'base',
                        themeVariables: {
                            primaryColor: 'var(--accent-primary)',
                            primaryTextColor: 'var(--text-primary)',
                            primaryBorderColor: 'var(--border-secondary)',
                            lineColor: 'var(--text-secondary)',
                            secondaryColor: 'var(--bg-tertiary)',
                            tertiaryColor: 'var(--bg-secondary)',
                            background: '#ffffff',
                            mainBkg: '#ffffff',
                            secondBkg: 'var(--bg-secondary)',
                            tertiaryBkg: 'var(--bg-tertiary)'
                        }
                    });
                }
            });
        };

        // Lazy load MathJax (only when needed)
        window.loadMathJax = function() {
            if (!window.MathJax) {
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\(', '\\)']],
                        displayMath: [['$$', '$$'], ['\\[', '\\]']],
                        processEscapes: true
                    },
                    svg: {
                        fontCache: 'global'
                    }
                };
            }
            return loadLibrary('mathjax', 'https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-svg.js');
        };
    </script>
    <link rel="stylesheet" href="/static/themes/themes.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<body>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="collapse-btn" id="collapse-btn" onclick="toggleSidebar()">
                <svg id="collapse-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <polyline points="15,18 9,12 15,6"></polyline>
                </svg>
            </div>
            <div class="sidebar-header">
                <h2>èŠå¤©ä¼šè¯</h2>
                <button class="new-chat-btn" onclick="createNewSession(false)">+ æ–°å»ºèŠå¤©</button>
            </div>
            <div class="sessions-list" id="sessions-list">
                <p style="padding: 20px; text-align: center; color: #7f8c8d;">åŠ è½½ä¸­...</p>
            </div>
            <div class="sidebar-footer">
                <div class="theme-selector-sidebar" id="theme-selector" onclick="showThemeModal()" title="ä¸»é¢˜è®¾ç½®">
                    <span class="theme-icon">ğŸ¨</span>
                </div>
                <div class="settings-btn" id="settings-btn" onclick="toggleSettingsMenu()" title="è®¾ç½®">
                    <span class="settings-icon">âš™ï¸</span>
                </div>
                <!-- Settings Dropdown Menu -->
                <div class="settings-menu" id="settings-menu" style="display: none;">
                    <div class="settings-menu-item">
                        <label class="settings-toggle">
                            <span class="settings-label">å¯ç”¨ Skills</span>
                            <input type="checkbox" id="user-enable-skills" checked onchange="handleSettingsChange()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="settings-menu-item">
                        <label class="settings-toggle">
                            <span class="settings-label">å¯ç”¨ MCP</span>
                            <input type="checkbox" id="user-enable-mcp" checked onchange="handleSettingsChange()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-area">
            <div class="chat-header">
                <div class="chat-header-left">
                    <h1 id="chat-title">LangGraphGo èŠå¤©</h1>
                    <div class="status" id="status">é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªä¼šè¯</div>
                </div>
                <div class="chat-header-right">
                    <div class="tools-status">
                        <div class="skills-status" id="skills-status" title="Skills çŠ¶æ€">
                            <span class="skills-indicator" id="skills-indicator"></span>
                            <span class="skills-text" id="skills-text">Skills</span>
                        </div>
                        <div class="mcp-status" id="mcp-status" title="MCP å·¥å…·çŠ¶æ€">
                            <span class="mcp-indicator" id="mcp-indicator"></span>
                            <span class="mcp-text" id="mcp-text">MCP</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="messages" id="messages">
                <div class="welcome">
                    <h2>ğŸ‘‹ æ¬¢è¿!</h2>
                    <p>åˆ›å»ºä¸€ä¸ªæ–°ä¼šè¯æˆ–é€‰æ‹©ç°æœ‰ä¼šè¯å¼€å§‹èŠå¤©ã€‚</p>
                </div>
            </div>
            <div class="input-area">
                <div class="input-container">
                    <input type="text" id="message-input" placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯..." disabled>
                    <button id="send-btn" onclick="sendMessage()" disabled>å‘é€</button>
                </div>
            </div>
        </div>

        <div class="artifacts-sidebar" id="artifacts-sidebar">
            <div class="artifacts-collapse-btn" id="artifacts-collapse-btn" onclick="toggleArtifactsSidebar()">
                <svg id="artifacts-collapse-icon" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <polyline points="9,18 15,12 9,6"></polyline>
                </svg>
            </div>
            <div class="artifacts-header" id="artifacts-header">
                <h2 id="artifacts-title">Artifacts</h2>
            </div>
            <div class="artifacts-content" id="artifacts-content">
                <div class="no-artifacts">No artifacts in this session</div>
            </div>
        </div>
    </div>

    <!-- Theme Modal -->
    <div class="modal" id="theme-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ¨ ä¸»é¢˜è®¾ç½®</h2>
                <button class="modal-close" onclick="closeThemeModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="theme-section">
                    <h3>â˜€ï¸ æµ…è‰²ä¸»é¢˜</h3>
                    <div class="theme-grid">
                        <div class="theme-option" onclick="setTheme('default-light')" data-theme="default-light">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 50%, #ffffff 100%);">
                            </div>
                            <span>é»˜è®¤ç»¿</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('blue-light')" data-theme="blue-light">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #ffffff 100%);">
                            </div>
                            <span>å¤©ç©ºè“</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('purple-light')" data-theme="purple-light">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 50%, #ffffff 100%);">
                            </div>
                            <span>ä¼˜é›…ç´«</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('rose-light')" data-theme="rose-light">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #fff1f2 0%, #ffe4e6 50%, #ffffff 100%);">
                            </div>
                            <span>ç«ç‘°çº¢</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('sapphire-light')" data-theme="sapphire-light">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #f0f4ff 0%, #e6eeff 50%, #ffffff 100%);">
                            </div>
                            <span>è“å®çŸ³</span>
                        </div>
                    </div>
                </div>
                <div class="theme-section">
                    <h3>ğŸŒ™ æ·±è‰²ä¸»é¢˜</h3>
                    <div class="theme-grid">
                        <div class="theme-option" onclick="setTheme('modern-dark')" data-theme="modern-dark">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #1e293b 0%, #334155 50%, #0f172a 100%);">
                            </div>
                            <span>ç°ä»£é»‘</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('blue-dark')" data-theme="blue-dark">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #192036 0%, #1e3a5f 50%, #0c1222 100%);">
                            </div>
                            <span>æ·±ç©ºè“</span>
                        </div>
                        <div class="theme-option" onclick="setTheme('cyberpunk-dark')" data-theme="cyberpunk-dark">
                            <div class="theme-preview"
                                style="background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #0a0a0a 100%);">
                            </div>
                            <span>èµ›åšæœ‹å…‹</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Skills Modal -->
    <div class="modal" id="skills-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ¯ Skills</h2>
                <button class="modal-close" onclick="closeSkillsModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div id="skills-list" class="hierarchical-list">
                    <p>åŠ è½½ä¸­...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MCP Tools Modal -->
    <div class="modal" id="mcp-tools-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>âš¡ MCP å·¥å…·</h2>
                <button class="modal-close" onclick="closeMCPToolsModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div id="mcp-tools-list" class="hierarchical-list">
                    <p>åŠ è½½ä¸­...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSessionId = null;
        let mcpTools = [];
        let skills = [];
        let hierarchicalData = null;
        let mcpEnabled = false;
        let chatConfig = {
            chatTitle: "LangGraphGo èŠå¤©"
        };

        // Theme Management
        let currentTheme = localStorage.getItem('chatTheme') || 'default-light';

        // Apply saved theme on load
        function applyTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            currentTheme = themeName;
            localStorage.setItem('chatTheme', themeName);

            // Update active state in theme selector
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === themeName) {
                    option.classList.add('active');
                }
            });
        }

        function setTheme(themeName) {
            applyTheme(themeName);
            closeThemeModal();
        }

        function showThemeModal() {
            const modal = document.getElementById('theme-modal');

            // Set active state for current theme
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === currentTheme) {
                    option.classList.add('active');
                }
            });

            modal.classList.add('show');
        }

        function closeThemeModal() {
            const modal = document.getElementById('theme-modal');
            modal.classList.remove('show');
        }

        // User Settings Management
        let userSettings = {
            enableSkills: true,
            enableMCP: true
        };

        // Update tools icons visibility based on user settings
        function updateToolsIconsVisibility() {
            const skillsStatus = document.getElementById('skills-status');
            const mcpStatus = document.getElementById('mcp-status');

            if (skillsStatus) {
                skillsStatus.style.display = userSettings.enableSkills ? 'flex' : 'none';
            }
            if (mcpStatus) {
                mcpStatus.style.display = userSettings.enableMCP ? 'flex' : 'none';
            }
        }

        // Load user settings from localStorage
        function loadUserSettings() {
            const saved = localStorage.getItem('userSettings');
            if (saved) {
                userSettings = JSON.parse(saved);
            }

            // Update checkbox states
            const skillsCheckbox = document.getElementById('user-enable-skills');
            const mcpCheckbox = document.getElementById('user-enable-mcp');

            if (skillsCheckbox) {
                skillsCheckbox.checked = userSettings.enableSkills;
            }
            if (mcpCheckbox) {
                mcpCheckbox.checked = userSettings.enableMCP;
            }

            // Update icons visibility
            updateToolsIconsVisibility();
        }

        // Save user settings to localStorage
        function saveUserSettings() {
            localStorage.setItem('userSettings', JSON.stringify(userSettings));
            console.log('User settings saved:', userSettings);
        }

        // Toggle settings menu
        function toggleSettingsMenu() {
            const menu = document.getElementById('settings-menu');
            if (menu.style.display === 'none' || menu.style.display === '') {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function(event) {
            const settingsBtn = document.getElementById('settings-btn');
            const settingsMenu = document.getElementById('settings-menu');

            if (settingsMenu && settingsBtn) {
                // Check if click is outside both button and menu
                if (!settingsBtn.contains(event.target) && !settingsMenu.contains(event.target)) {
                    settingsMenu.style.display = 'none';
                }
            }
        });

        // Handle settings changes
        function handleSettingsChange() {
            const skillsCheckbox = document.getElementById('user-enable-skills');
            const mcpCheckbox = document.getElementById('user-enable-mcp');

            if (skillsCheckbox) {
                userSettings.enableSkills = skillsCheckbox.checked;
            }
            if (mcpCheckbox) {
                userSettings.enableMCP = mcpCheckbox.checked;
            }

            saveUserSettings();

            // Update icons visibility immediately
            updateToolsIconsVisibility();
        }

        // Load chat configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (response.ok) {
                    const config = await response.json();
                    chatConfig = config;

                    // Update page title
                    document.getElementById('page-title').textContent = config.chatTitle;

                    // Update chat title in header
                    const chatTitleElement = document.getElementById('chat-title');
                    if (chatTitleElement) {
                        chatTitleElement.textContent = config.chatTitle;
                    }
                }
            } catch (error) {
                console.log('Failed to load config:', error);
                // Use default values
            }
        }

        // Initialize artifacts sidebar as collapsed by default
        document.addEventListener('DOMContentLoaded', () => {
            // Load configuration first
            loadConfig();

            // Load user settings
            loadUserSettings();

            // Apply saved theme
            applyTheme(currentTheme);

            const artifactsSidebar = document.getElementById('artifacts-sidebar');
            if (artifactsSidebar) {
                artifactsSidebar.classList.add('collapsed');
                isArtifactsOpen = false; // Ensure state is consistent
            }

            // Add click listener to Skills status
            const skillsStatus = document.getElementById('skills-status');
            if (skillsStatus) {
                skillsStatus.addEventListener('click', showSkillsModal);
            }

            // Add click listener to MCP status
            const mcpStatus = document.getElementById('mcp-status');
            if (mcpStatus) {
                mcpStatus.addEventListener('click', showMCPToolsModal);
            }
        });
        let sidebarCollapsed = false;
        let artifacts = new Map(); // Store artifacts by ID
        let currentArtifactId = null; // Track currently displayed artifact

        // Load config and sessions on page load - delay to improve perceived performance
        setTimeout(loadConfig, 0);
        setTimeout(loadSessions, 100);

        // Enable Enter key to send message
        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        async function loadSessions() {
            const sessionsList = document.getElementById('sessions-list');
            // Show loading state immediately
            if (sessionsList.children.length === 0) {
                sessionsList.innerHTML = '<p style="padding: 20px; text-align: center; color: #7f8c8d;">åŠ è½½ä¸­...</p>';
            }

            try {
                // Use a timeout to prevent long waiting
                const response = await Promise.race([
                    fetch('/api/sessions'),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Timeout')), 5000)
                    )
                ]);

                const sessions = await response.json();
                sessionsList.innerHTML = '';

                if (sessions.length === 0) {
                    // Auto-create first session if none exists
                    sessionsList.innerHTML = '<p style="padding: 20px; text-align: center; color: #7f8c8d;">åˆ›å»ºä¼šè¯ä¸­...</p>';
                    // Use setTimeout to not block the UI
                    setTimeout(() => createNewSession(true), 50);
                    return;
                }

                sessions.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));

                // Auto-select the most recent session if no current session is selected
                if (!currentSessionId && sessions.length > 0) {
                    selectSession(sessions[0].id);
                }

                sessions.forEach(session => {
                    const item = document.createElement('div');
                    item.className = 'session-item' + (session.id === currentSessionId ? ' active' : '');
                    item.setAttribute('data-session-id', session.id);
                    item.innerHTML = `
                        <div class="session-title">${session.title || 'æ–°ä¼šè¯'}</div>
                        <div class="session-meta-row">
                            <div class="session-meta">${session.message_count} æ¡æ¶ˆæ¯ â€¢ ${formatDate(session.updated_at)}</div>
                            <button class="session-action-btn delete-btn" onclick="deleteSession('${session.id}', event)">åˆ é™¤</button>
                        </div>
                    `;
                    item.onclick = () => selectSession(session.id);
                    sessionsList.appendChild(item);
                });
            } catch (error) {
                console.error('Failed to load sessions:', error);
                if (sessionsList.innerHTML.includes('åŠ è½½ä¸­')) {
                    sessionsList.innerHTML = '<p style="padding: 20px; text-align: center; color: #e74c3c;">åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢</p>';
                }
            }
        }

        async function createNewSession(autoSelect = false) {
            try {
                const response = await fetch('/api/sessions/new', { method: 'POST' });
                const data = await response.json();

                if (autoSelect) {
                    // For auto-created sessions, directly select without reloading
                    currentSessionId = data.session_id;
                    document.getElementById('message-input').disabled = false;
                    document.getElementById('send-btn').disabled = false;
                    document.getElementById('status').textContent = '';
                    // Load history (will be empty for new session)
                    await loadHistory(data.session_id);
                } else {
                    // For manual clicks, reload the full session list
                    await loadSessions();
                    selectSession(data.session_id);
                }
            } catch (error) {
                console.error('Failed to create session:', error);
                alert('Failed to create new session');
            }
        }

        async function selectSession(sessionId) {
            // Clear and save current artifacts before switching
            clearArtifacts();

            currentSessionId = sessionId;
            document.getElementById('message-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
            document.getElementById('status').textContent = ``;

            // Update UI
            document.querySelectorAll('.session-item').forEach(item => {
                item.classList.remove('active');
            });

            // Find and highlight the selected session
            const selectedItem = document.querySelector(`[data-session-id="${sessionId}"]`);
            if (selectedItem) {
                selectedItem.classList.add('active');
            }

            // Load history
            await loadHistory(sessionId);

            // Update MCP status for the new session
            await updateToolsStatus();
        }

        async function loadHistory(sessionId) {
            try {
                const response = await fetch(`/api/sessions/${sessionId}/history`);
                const messages = await response.json();

                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = '';

                // Clear artifacts before loading history
                artifacts.clear();

                for (const msg of messages) {
                    await addMessageToUI(msg.role, msg.content, msg.timestamp);
                }

                scrollToBottom();
            } catch (error) {
                console.error('Failed to load history:', error);
            }
        }

        async function sendMessage() {
            if (!currentSessionId) return;

            const input = document.getElementById('message-input');
            const message = input.value.trim();
            if (!message) return;

            // Disable input
            input.disabled = true;
            document.getElementById('send-btn').disabled = true;

            // Add user message to UI
            await addMessageToUI('user', message, new Date());
            input.value = '';

            // Show typing indicator
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message assistant';
            typingDiv.innerHTML = `
                <div class="message-content typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            document.getElementById('messages').appendChild(typingDiv);
            scrollToBottom();

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        message: message,
                        user_settings: {
                            enable_skills: userSettings.enableSkills,
                            enable_mcp: userSettings.enableMCP
                        }
                    })
                });

                const data = await response.json();

                // Remove typing indicator
                typingDiv.remove();

                // Add assistant response
                await addMessageToUI('assistant', data.response, new Date());

                // Reload sessions to update message count
                loadSessions();
            } catch (error) {
                console.error('Failed to send message:', error);
                typingDiv.remove();
                addErrorMessage('Failed to get response. Please try again.');
            } finally {
                input.disabled = false;
                document.getElementById('send-btn').disabled = false;
                input.focus();
            }
        }

        async function addMessageToUI(role, content, timestamp) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const time = new Date(timestamp).toLocaleTimeString();
            let processedContent = '';
            let extractedArtifacts = [];

            if (role === 'assistant') {
                // First extract artifacts from content
                const result = extractArtifacts(content);
                extractedArtifacts = result.artifacts;

                console.log('Extracted artifacts:', extractedArtifacts); // Debug log
                console.log('Current session ID:', currentSessionId); // Debug log

                // Store artifacts
                extractedArtifacts.forEach(artifact => {
                    artifacts.set(artifact.id, artifact);
                });

                console.log('All artifacts after adding:', Array.from(artifacts.entries())); // Debug log

                // Parse Markdown (this will convert code blocks to HTML)
                processedContent = marked.parse(result.content);

                // Find and replace artifact markers in the parsed HTML
                const markerRegex = /<!-- ARTIFACT:(.*?) -->/g;
                    processedContent = processedContent.replace(markerRegex, (match, artifactId) => {
                        const artifact = artifacts.get(artifactId);
                        if (artifact) {
                            return `<div class="artifact-placeholder" data-artifact-id="${artifactId}">
                            <span class="artifact-placeholder-icon">${getTypeIcon(artifact.type)}</span>
                            <div class="artifact-placeholder-text">
                                <div class="artifact-placeholder-label">Artifact</div>
                                <div class="artifact-placeholder-title">${artifact.title}</div>
                            </div>
                            <span class="artifact-placeholder-arrow">â†’</span>
                        </div>`;
                        }
                        return match;
                    });

                // Update artifacts display
                if (isArtifactsOpen) {
                    updateArtifactsDisplay();
                }
            } else {
                // Escape HTML for user messages
                processedContent = escapeHtml(content);
            }

            const messageContentDiv = document.createElement('div');
            messageContentDiv.className = 'message-content';

            if (role === 'assistant') {
                const copyBtn = document.createElement('div');
                copyBtn.className = 'copy-btn';
                copyBtn.innerHTML = '&#x1f4cb; <span>Copy</span>';
                copyBtn.setAttribute('data-raw-content', content);
                copyBtn.onclick = (e) => copyToClipboard(e);

                const footer = document.createElement('div');
                footer.className = 'message-footer';

                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = time;

                footer.appendChild(timeDiv);
                footer.appendChild(copyBtn);

                messageContentDiv.innerHTML = processedContent;
                messageContentDiv.appendChild(footer);

            } else {
                messageContentDiv.innerHTML = `
                    ${processedContent}
                    <div class="message-time">${time}</div>
                `;
            }

            messageDiv.appendChild(messageContentDiv);
            messagesDiv.appendChild(messageDiv);

            // Add click handler for artifact placeholders
            const placeholders = messageDiv.querySelectorAll('.artifact-placeholder');
            placeholders.forEach(placeholder => {
                // Add click handler
                placeholder.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const artifactId = this.getAttribute('data-artifact-id');
                    console.log('Artifact clicked:', artifactId); // Debug log
                    openArtifactsModal();
                    showArtifact(artifactId);
                });
            });

            // Process MathJax, Mermaid, and Highlight.js
            if (role === 'assistant') {
                // Check if message contains math formulas and load MathJax if needed
                if (processedContent.includes('$') || processedContent.includes('\\[') || processedContent.includes('\\(')) {
                    await window.loadMathJax();
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        try {
                            await window.MathJax.typesetPromise([messageDiv]);
                        } catch (e) {
                            console.error("MathJax rendering error:", e);
                        }
                    }
                }

                // Check if message contains Mermaid diagrams
                const mermaidCodeBlocks = messageDiv.querySelectorAll('pre code.language-mermaid');
                if (mermaidCodeBlocks.length > 0) {
                    await window.loadMermaid();

                    for (const codeBlock of mermaidCodeBlocks) {
                        const code = codeBlock.textContent;
                        const mermaidDiv = document.createElement('div');
                        mermaidDiv.className = 'mermaid';
                        mermaidDiv.textContent = code;
                        codeBlock.parentNode.replaceWith(mermaidDiv);
                    }

                    if (typeof mermaid !== 'undefined') {
                        try {
                            await mermaid.run({
                                nodes: messageDiv.querySelectorAll('.mermaid')
                            });
                        } catch (e) {
                            console.error("Mermaid rendering error:", e);
                        }
                    }
                }

                // Highlight code blocks (wait for highlight.js if needed)
                if (typeof hljs !== 'undefined') {
                    messageDiv.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                    });
                } else {
                    // Wait for highlight.js to load
                    await window.librariesLoading['highlightjs'];
                    if (typeof hljs !== 'undefined') {
                        messageDiv.querySelectorAll('pre code').forEach((block) => {
                            hljs.highlightElement(block);
                        });
                    }
                }
            }

            scrollToBottom();
        }

        function copyToClipboard(event) {
            const button = event.currentTarget;
            const rawContent = button.getAttribute('data-raw-content');
            navigator.clipboard.writeText(rawContent).then(() => {
                const originalText = button.innerHTML;
                button.innerHTML = 'âœ“ Copied!';
                button.style.color = '#27ae60'; // Green color for success
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.color = ''; // Revert color
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
            event.stopPropagation();
        }

        function addErrorMessage(message) {
            const messagesDiv = document.getElementById('messages');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            messagesDiv.appendChild(errorDiv);
            scrollToBottom();
        }

        async function deleteSession(sessionId, event) {
            event.stopPropagation();
            if (!confirm('ç¡®å®šè¦æ°¸ä¹…åˆ é™¤æ­¤ä¼šè¯å—ï¼Ÿ')) return;

            try {
                await fetch(`/api/sessions/${sessionId}`, { method: 'DELETE' });

                if (sessionId === currentSessionId) {
                    currentSessionId = null;
                    document.getElementById('messages').innerHTML = '<div class="welcome"><h2>ğŸ‘‹ æ¬¢è¿!</h2><p>åˆ›å»ºä¸€ä¸ªæ–°ä¼šè¯æˆ–é€‰æ‹©ç°æœ‰ä¼šè¯å¼€å§‹èŠå¤©ã€‚</p></div>';
                    document.getElementById('message-input').disabled = true;
                    document.getElementById('send-btn').disabled = true;
                    document.getElementById('status').textContent = 'é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªä¼šè¯';

                    // Clear artifacts if we're deleting the current session
                    clearArtifacts();
                }
                loadSessions();
            } catch (error) {
                console.error('Failed to delete session:', error);
                alert('Failed to delete session');
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebarCollapsed = !sidebarCollapsed;

            if (sidebarCollapsed) {
                sidebar.classList.add('collapsed');
            } else {
                sidebar.classList.remove('collapsed');
            }
        }

        function scrollToBottom() {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const diff = now - date;

            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
            return date.toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        // Artifacts Functions
        function extractArtifacts(content) {
            const artifacts = [];
            let processedContent = content;

            // Types that should be extracted as artifacts
            const artifactTypes = ['html', 'svg', 'python', 'javascript', 'js', 'shell', 'bash', 'sh',
                'css', 'json', 'yaml', 'yml', 'sql', 'docker', 'dockerfile',
                'go', 'java', 'cpp', 'c', 'rust', 'typescript', 'ts',
                'php', 'ruby', 'swift', 'kotlin', 'markdown', 'md'];

            // Extract code blocks using regex pattern
            // Format: ```language ... ```
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;

            let match;
            let artifactIndex = 0;

            while ((match = codeBlockRegex.exec(content)) !== null) {
                const language = match[1] || 'text';
                const codeContent = match[2].trim();

                // Count the number of lines in the code block
                const lineCount = codeContent.split('\n').length;

                // Check if this type should be extracted as artifact AND has more than 100 lines
                if (artifactTypes.includes(language.toLowerCase()) && lineCount > 100) {
                    const artifactId = `artifact_${Date.now()}_${artifactIndex++}`;
                    const type = language.toLowerCase();

                    // Generate a smart title based on content
                    let title = generateArtifactTitle(codeContent, type);

                    artifacts.push({
                        id: artifactId,
                        type: type,
                        language: language,
                        title: title,
                        content: codeContent
                    });

                    // Replace code block with placeholder marker
                    processedContent = processedContent.replace(match[0],
                        `<!-- ARTIFACT:${artifactId} -->`);
                }
            }

            return {
                content: processedContent,
                artifacts: artifacts
            };
        }

        function generateArtifactTitle(content, type) {
            // Try to extract a meaningful title from the content
            const lines = content.split('\n').filter(line => line.trim());

            // For HTML, look for title tag
            if (type === 'html') {
                const titleMatch = content.match(/<title>(.*?)<\/title>/i);
                if (titleMatch) return titleMatch[1];
            }

            // For Python/JavaScript/Java, look for function/class/variable definitions
            if (['python', 'javascript', 'js', 'java', 'go', 'rust', 'typescript', 'ts'].includes(type)) {
                const funcMatch = lines.find(line =>
                    line.match(/^(def|function|func|fn)\s+\w+/) ||
                    line.match(/^class\s+\w+/) ||
                    line.match(/^(const|let|var)\s+\w+/)
                );
                if (funcMatch) return funcMatch.trim().split(/\s+/)[1];
            }

            // For shell/bash, look for shebang or first command
            if (['shell', 'bash', 'sh'].includes(type)) {
                if (lines[0] && lines[0].startsWith('#!')) {
                    return lines[0].substring(2).trim();
                }
            }

            // For CSS, look for class or ID selectors
            if (type === 'css') {
                const selectorMatch = lines.find(line =>
                    line.match(/^\.[\w-]+\s*\{/) ||
                    line.match(/^#[\w-]+\s*\{/)
                );
                if (selectorMatch) return selectorMatch.trim().split(/\s+/)[0];
            }

            // For Dockerfile
            if (type === 'dockerfile' || type === 'docker') {
                const fromMatch = lines.find(line => line.startsWith('FROM'));
                if (fromMatch) return `Dockerfile - ${fromMatch}`;
            }

            // Default: use first line or type name
            if (lines.length > 0 && lines[0].length < 50) {
                return lines[0].substring(0, 30);
            }

            return `${type.charAt(0).toUpperCase() + type.slice(1)} Code`;
        }

        let isArtifactsOpen = false;

        function clearArtifacts() {
            console.log('Clearing artifacts...'); // Debug log

            // Clear current artifacts
            artifacts.clear();
            currentArtifactId = null;

            // Update display
            updateArtifactsDisplay();

            // Close sidebar
            if (isArtifactsOpen) {
                const artifactsSidebar = document.getElementById('artifacts-sidebar');
                artifactsSidebar.classList.add('collapsed');
                isArtifactsOpen = false;
            }
        }


        function toggleArtifactsSidebar() {
            const artifactsSidebar = document.getElementById('artifacts-sidebar');

            console.log('Toggling artifacts sidebar, current artifacts count:', artifacts.size); // Debug log

            isArtifactsOpen = !isArtifactsOpen;

            if (isArtifactsOpen) {
                artifactsSidebar.classList.remove('collapsed');
                updateArtifactsDisplay();
            } else {
                artifactsSidebar.classList.add('collapsed');
            }
        }

        function updateArtifactsDisplay() {
            const titleElement = document.getElementById('artifacts-title');
            const headerElement = document.getElementById('artifacts-header');
            const contentContainer = document.getElementById('artifacts-content');

            if (artifacts.size === 0) {
                headerElement.innerHTML = '<h2 id="artifacts-title">Artifacts</h2>';
                contentContainer.innerHTML = '<div class="no-artifacts">No artifacts in this session</div>';
                currentArtifactId = null;
                return;
            }

            // If there's a current artifact, update the header to show its info
            if (currentArtifactId && artifacts.has(currentArtifactId)) {
                const artifact = artifacts.get(currentArtifactId);
                const icon = getTypeIcon(artifact.type);
                headerElement.innerHTML = `<h2 id="artifacts-title">${icon} ${artifact.title}</h2>`;
            } else {
                // Show first artifact if none selected
                const firstArtifactId = artifacts.keys().next().value;
                if (firstArtifactId) {
                    showArtifact(firstArtifactId);
                }
            }
        }

        function openArtifactsModal() {
            if (!isArtifactsOpen) {
                toggleArtifactsSidebar();
            }
        }

        function closeArtifactsModal() {
            if (isArtifactsOpen) {
                toggleArtifactsSidebar();
            }
        }

        function showArtifact(artifactId) {
            const artifact = artifacts.get(artifactId);
            if (!artifact) {
                return;
            }

            // Update current artifact ID
            currentArtifactId = artifactId;

            // Ensure artifacts sidebar is open
            if (!isArtifactsOpen) {
                const artifactsSidebar = document.getElementById('artifacts-sidebar');
                artifactsSidebar.classList.remove('collapsed');
                isArtifactsOpen = true;
            }

            // Update header with current artifact info
            const headerElement = document.getElementById('artifacts-header');
            const icon = getTypeIcon(artifact.type);
            headerElement.innerHTML = `<h2 id="artifacts-title">${icon} ${artifact.title}</h2>`;

            // Show artifact content
            const content = document.getElementById('artifacts-content');
            content.innerHTML = '<div class="artifact-full">' + renderArtifactContent(artifact) + '</div>';
        }

        function getTypeIcon(type) {
            const icons = {
                'html': 'ğŸŒ',
                'svg': 'ğŸ¨',
                'python': 'ğŸ',
                'javascript': 'âš¡',
                'shell': 'ğŸ–¥ï¸',
                'bash': 'ğŸ–¥ï¸',
                'markdown': 'ğŸ“',
                'json': 'ğŸ“‹',
                'yaml': 'ğŸ“‹',
                'css': 'ğŸ¨',
                'sql': 'ğŸ—„ï¸',
                'docker': 'ğŸ³',
                'kubernetes': 'â˜¸ï¸',
                'terraform': 'ğŸ—ï¸',
                'go': 'ğŸ¹',
                'java': 'â˜•',
                'cpp': 'âš™ï¸',
                'c': 'âš™ï¸',
                'rust': 'ğŸ¦€',
                'typescript': 'ğŸ“˜',
                'php': 'ğŸ˜',
                'ruby': 'ğŸ’',
                'swift': 'ğŸ',
                'kotlin': 'ğŸ¯'
            };
            return icons[type] || 'ğŸ“„';
        }

        function renderArtifactContent(artifact) {
            const { type, content, language } = artifact;

            switch (type) {
                case 'html':
                    return `<iframe srcdoc="${escapeHtml(content)}"></iframe>`;

                case 'svg':
                    return content;

                case 'python':
                case 'javascript':
                case 'js':
                case 'shell':
                case 'bash':
                case 'sh':
                case 'markdown':
                case 'md':
                case 'json':
                case 'yaml':
                case 'yml':
                case 'css':
                case 'sql':
                case 'docker':
                case 'dockerfile':
                case 'go':
                case 'java':
                case 'cpp':
                case 'c':
                case 'rust':
                case 'typescript':
                case 'ts':
                case 'php':
                case 'ruby':
                case 'swift':
                case 'kotlin':
                case 'text':
                default:
                    // Map types to highlight.js languages
                    const langMap = {
                        'js': 'javascript',
                        'ts': 'typescript',
                        'sh': 'bash',
                        'dockerfile': 'dockerfile',
                        'md': 'markdown',
                        'yml': 'yaml'
                    };
                    const hlLang = langMap[type] || language || type;

                    // Try to highlight, fallback to plaintext if language not supported
                    let highlighted;
                    try {
                        highlighted = hljs.highlight(content, { language: hlLang }).value;
                    } catch (e) {
                        highlighted = hljs.highlight(content, { language: 'plaintext' }).value;
                    }
                    return `<pre><code>${highlighted}</code></pre>`;
            }
        }


        // Tools Functions
        let toolsRefreshInterval = null; // Store interval ID for cleanup

        async function loadHierarchicalData(retryCount = 0) {
            if (!currentSessionId) return;

            try {
                const response = await fetch(`/api/tools/hierarchical?session_id=${currentSessionId}`);
                if (response.ok) {
                    hierarchicalData = await response.json();

                    // Update status indicators
                    mcpEnabled = hierarchicalData.enabled;
                    skills = hierarchicalData.skills || [];
                    mcpTools = [];

                    // Flatten MCP tools for status count
                    if (hierarchicalData.mcp_tools) {
                        hierarchicalData.mcp_tools.forEach(category => {
                            mcpTools = mcpTools.concat(category.tools || []);
                        });
                    }

                    // Update Skills status
                    const skillsIndicator = document.getElementById('skills-indicator');
                    const skillsText = document.getElementById('skills-text');

                    if (skills.length > 0) {
                        skillsIndicator.classList.remove('disabled');
                        skillsText.textContent = `Skills (${skills.length})`;
                        document.getElementById('skills-status').title = `å·²åŠ è½½ ${skills.length} ä¸ª Skills`;
                    } else {
                        skillsIndicator.classList.add('disabled');
                        skillsText.textContent = hierarchicalData.tools_loading ? 'Skills (åŠ è½½ä¸­...)' : 'Skills';
                        document.getElementById('skills-status').title = hierarchicalData.tools_loading ? 'Skills æ­£åœ¨åŠ è½½ä¸­...' : 'æš‚æ—  Skills';
                    }

                    // Update MCP status
                    const mcpIndicator = document.getElementById('mcp-indicator');
                    const mcpText = document.getElementById('mcp-text');

                    if (mcpEnabled && mcpTools.length > 0) {
                        mcpIndicator.classList.remove('disabled');
                        mcpText.textContent = `MCP (${mcpTools.length})`;
                        document.getElementById('mcp-status').title = `å·²åŠ è½½ ${mcpTools.length} ä¸ª MCP å·¥å…·`;
                    } else {
                        mcpIndicator.classList.add('disabled');
                        mcpText.textContent = hierarchicalData.tools_loading ? 'MCP (åŠ è½½ä¸­...)' : 'MCP';
                        document.getElementById('mcp-status').title = hierarchicalData.tools_loading ? 'MCP å·¥å…·æ­£åœ¨åŠ è½½ä¸­...' : 'MCP å·¥å…·æœªå¯ç”¨';
                    }

                    // If tools are still loading, retry after a delay
                    if (hierarchicalData.tools_loading && !hierarchicalData.tools_loaded && retryCount < 20) {
                        setTimeout(() => {
                            console.log('Tools still loading, retrying...');
                            loadHierarchicalData(retryCount + 1);
                        }, 1000); // Retry every 1 second
                    } else if (hierarchicalData.tools_loaded) {
                        console.log('Tools loaded successfully');
                        // Clear any existing interval
                        if (toolsRefreshInterval) {
                            clearInterval(toolsRefreshInterval);
                            toolsRefreshInterval = null;
                        }
                    }
                } else {
                    // Server doesn't support hierarchical tools, fall back to old method
                    await updateToolsStatusLegacy();
                }
            } catch (error) {
                console.log('Hierarchical tools not available, using legacy:', error);
                await updateToolsStatusLegacy();
            }
        }

        async function updateToolsStatusLegacy() {
            try {
                const response = await fetch(`/api/mcp/tools?session_id=${currentSessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    mcpEnabled = data.enabled;
                    const allTools = data.tools || [];

                    // Separate skills and MCP tools
                    skills = allTools.filter(tool => tool.type === 'skill');
                    mcpTools = allTools.filter(tool => tool.type === 'mcp');

                    // Update Skills status
                    const skillsIndicator = document.getElementById('skills-indicator');
                    const skillsText = document.getElementById('skills-text');

                    if (skills.length > 0) {
                        skillsIndicator.classList.remove('disabled');
                        skillsText.textContent = `Skills (${skills.length})`;
                        document.getElementById('skills-status').title = `å·²åŠ è½½ ${skills.length} ä¸ª Skills`;
                    } else {
                        skillsIndicator.classList.add('disabled');
                        skillsText.textContent = 'Skills';
                        document.getElementById('skills-status').title = 'æš‚æ—  Skills';
                    }

                    // Update MCP status
                    const mcpIndicator = document.getElementById('mcp-indicator');
                    const mcpText = document.getElementById('mcp-text');

                    if (mcpEnabled && mcpTools.length > 0) {
                        mcpIndicator.classList.remove('disabled');
                        mcpText.textContent = `MCP (${mcpTools.length})`;
                        document.getElementById('mcp-status').title = `å·²åŠ è½½ ${mcpTools.length} ä¸ª MCP å·¥å…·`;
                    } else {
                        mcpIndicator.classList.add('disabled');
                        mcpText.textContent = 'MCP';
                        document.getElementById('mcp-status').title = 'MCP å·¥å…·æœªå¯ç”¨';
                    }
                } else {
                    // Server doesn't support MCP
                    updateToolsDisabled();
                }
            } catch (error) {
                console.log('Tools not available:', error);
                updateToolsDisabled();
            }
        }

        async function updateToolsStatus() {
            if (hierarchicalData) {
                // Data already loaded, just update counts
                const skillsIndicator = document.getElementById('skills-indicator');
                const skillsText = document.getElementById('skills-text');
                const mcpIndicator = document.getElementById('mcp-indicator');
                const mcpText = document.getElementById('mcp-text');

                if (skills.length > 0) {
                    skillsIndicator.classList.remove('disabled');
                    skillsText.textContent = `Skills (${skills.length})`;
                    document.getElementById('skills-status').title = `å·²åŠ è½½ ${skills.length} ä¸ª Skills`;
                } else {
                    skillsIndicator.classList.add('disabled');
                    skillsText.textContent = 'Skills';
                    document.getElementById('skills-status').title = 'æš‚æ—  Skills';
                }

                if (mcpEnabled && mcpTools.length > 0) {
                    mcpIndicator.classList.remove('disabled');
                    mcpText.textContent = `MCP (${mcpTools.length})`;
                    document.getElementById('mcp-status').title = `å·²åŠ è½½ ${mcpTools.length} ä¸ª MCP å·¥å…·`;
                } else {
                    mcpIndicator.classList.add('disabled');
                    mcpText.textContent = 'MCP';
                    document.getElementById('mcp-status').title = 'MCP å·¥å…·æœªå¯ç”¨';
                }
            } else {
                await loadHierarchicalData();
            }
        }

        function toggleCategory(index, type) {
            const toolsId = type === 'skill' ? `skill-tools-${index}` : `mcp-tools-${index}`;
            const toolsElement = document.getElementById(toolsId);
            const headerElement = toolsElement.previousElementSibling;

            if (toolsElement.classList.contains('expanded')) {
                toolsElement.classList.remove('expanded');
                headerElement.classList.remove('active');
            } else {
                toolsElement.classList.add('expanded');
                headerElement.classList.add('active');
            }
        }

        function updateToolsDisabled() {
            const skillsIndicator = document.getElementById('skills-indicator');
            const skillsText = document.getElementById('skills-text');
            const mcpIndicator = document.getElementById('mcp-indicator');
            const mcpText = document.getElementById('mcp-text');

            skillsIndicator.classList.add('disabled');
            skillsText.textContent = 'Skills';
            document.getElementById('skills-status').title = 'Skills æœªå¯ç”¨';

            mcpIndicator.classList.add('disabled');
            mcpText.textContent = 'MCP';
            document.getElementById('mcp-status').title = 'MCP æœªå¯ç”¨';
        }

        async function showSkillsModal() {
            const modal = document.getElementById('skills-modal');
            const skillsList = document.getElementById('skills-list');

            // Load hierarchical data if not loaded
            if (!hierarchicalData) {
                await loadHierarchicalData();
            }

            if (!hierarchicalData || hierarchicalData.skills.length === 0) {
                skillsList.innerHTML = '<div class="no-tools">æš‚æ— å¯ç”¨ Skills</div>';
            } else {
                skillsList.innerHTML = hierarchicalData.skills.map((skill, index) => `
                    <div class="category-item">
                        <div class="category-header" onclick="toggleCategory(${index}, 'skill')">
                            <div class="category-info">
                                <div class="category-name">${escapeHtml(skill.name)}</div>
                                <div class="category-description">${escapeHtml(skill.description)}</div>
                            </div>
                            <div class="expand-icon">â–¶</div>
                        </div>
                        <div class="category-tools" id="skill-tools-${index}">
                            ${skill.tools && skill.tools.length > 0 ?
                        skill.tools.map(tool => `
                                    <div class="tool-item">
                                        <div class="tool-name">${escapeHtml(tool.name)}</div>
                                        <div class="tool-description">${escapeHtml(tool.description)}</div>
                                    </div>
                                `).join('') :
                        '<div class="tool-item"><div class="tool-description">æš‚æ— å·¥å…·</div></div>'
                    }
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.add('show');
        }

        function closeSkillsModal() {
            const modal = document.getElementById('skills-modal');
            modal.classList.remove('show');
        }

        async function showMCPToolsModal() {
            const modal = document.getElementById('mcp-tools-modal');
            const mcpToolsList = document.getElementById('mcp-tools-list');

            // Load hierarchical data if not loaded
            if (!hierarchicalData) {
                await loadHierarchicalData();
            }

            if (!hierarchicalData || !hierarchicalData.enabled || hierarchicalData.mcp_tools.length === 0) {
                mcpToolsList.innerHTML = '<div class="no-tools">æš‚æ— å¯ç”¨ MCP å·¥å…·</div>';
            } else {
                mcpToolsList.innerHTML = hierarchicalData.mcp_tools.map((category, index) => `
                    <div class="category-item">
                        <div class="category-header" onclick="toggleCategory(${index}, 'mcp')">
                            <div class="category-info">
                                <div class="category-name">${escapeHtml(category.category)}</div>
                                <div class="category-description">${escapeHtml(category.description)} (${category.tools.length} tools)</div>
                            </div>
                            <div class="expand-icon">â–¶</div>
                        </div>
                        <div class="category-tools" id="mcp-tools-${index}">
                            ${category.tools.map(tool => `
                                <div class="tool-item">
                                    <div class="tool-name">${escapeHtml(tool.name)}</div>
                                    <div class="tool-description">${escapeHtml(tool.description)}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.add('show');
        }

        function closeMCPToolsModal() {
            const modal = document.getElementById('mcp-tools-modal');
            modal.classList.remove('show');
        }

        // Close modal when clicking outside
        document.getElementById('skills-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeSkillsModal();
            }
        });

        document.getElementById('mcp-tools-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeMCPToolsModal();
            }
        });

        // Escape key to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close any open modal
                const skillsModal = document.getElementById('skills-modal');
                const mcpModal = document.getElementById('mcp-tools-modal');
                const themeModal = document.getElementById('theme-modal');

                if (skillsModal.classList.contains('show')) {
                    closeSkillsModal();
                }
                if (mcpModal.classList.contains('show')) {
                    closeMCPToolsModal();
                }
                if (themeModal.classList.contains('show')) {
                    closeThemeModal();
                }
            }
        });

        // Close modal when clicking outside
        document.getElementById('theme-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeThemeModal();
            }
        });
    </script>
</body>

</html>